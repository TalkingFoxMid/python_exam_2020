# 2. Базовые структуры данных: tuple, list, set, frozenset, dict. Comprehensions. Модули copy, collections, heapq, enum.

## **Список ( list )** -- <class 'list'>

**Список** - упорядоченная изменяемая коллекция объектов произвольных типов.

Создать список можно несколькими способами:
```python
new_list = list()
new_list = list('Hello')
new_list = []
new_list = [1, 2, 3]
new_list = [i for i in any_iterable_object]
new_list = list(any_iterable_object)
```

Поддерживаются отрицательные индексы(по правилу a[-3] = a[len(a)-3]), срезы, сложение списков, умножение на число(объединение n оригинальных списков в новый)
### Отрицательные индексы.
```python
a = [1, 2, 3 , 4, 5]
print(a[-3]) # 3
print(a[len(a) - 3]) # 3
```
Следующая индексации записи аналогичны:
```python
a = list(...)
a[-i]
a[len(a)-i]
```
При чём для листа длины **n** допустима индексация по числам: $i=-n,...,n-1$

### Методы класса list:
| Название метода  | Функция |
|:---------------|-----:|
| list.append(x)    | Добавляет элемент в конец списка  |
| list.extend(L)  | Расширяет список list, добавляя в конец все элементы списка L  |	
|list.insert(i, x)|	Вставляет на i-ую позицию значение x|
|list.remove(x)	|Удаляет первый элемент в списке, имеющий значение x|
|list.pop([i])|	Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент
|list.index(x, [start [, end]])	|Возвращает положение первого элемента от start до end со значением x
|list.count(x)	|Возвращает количество элементов со значением x
|list.sort([key = функция])|	Сортирует список на основе функции
|list.reverse()|	Разворачивает список
|list.copy()|	Поверхностная копия списка(создает новый составной объект, и затем (по мере возможности) вставляет в него ссылки на объекты, находящиеся в оригинале)
|list.clear()|	Очищает список
##
## Кортеж ( tuple ) -- <class 'tuple'>

**Кортеж** — это неизменяемый список. С момента создания кортеж не может быть изменен никакими способами.

Варианты создания кортежей:
```python
new_tuple = tuple()
new_tuple = tuple('Hello')
new_tuple = ()
new_tuple = (1, 2, 3)
new_tuple = tuple(i for i in any_iterable_object)
new_tuple = tuple(any_iterable_object)
```
> Котрежи не поддерживают Comprehensions. 
Конструкция (i for i in any_iterable_object) возвращает генератор.


```python
# Сложение двух кортежей, возвращает новый кортеж, содержащий идущие друг за другом элементы первого и второго кортежей.
> (1, 2, 3)+(4, 5, 6) = (1, 2, 3, 4, 5, 6)
# Умножение кортежа на число n возвращает новый кортеж, в котором элементы изначального кортежа повторены n раз.
> (1, 6)*3 =(1, 6, 1, 6, 1, 6)
```

Так для чего же нужны кортежи?

- Работа с кортежами быстрее, чем со списками. Если вы определяете постоянный набор значений, и все, что вы хотите с ним когда-либо делать, это перебирать его элементы, используйте кортеж вместо списка.
- Кортежи могут быть ключами словаря, а списки нет. (поскольку кортежи -- хэшируемый тип)

**Замечание**: a = tuple('Hello World!') будет преобразовано в ('H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!') , при выводе а

Кортеж может быть преобразован в список и наоборот. Конструктор tuple воспринимает список в качестве аргумента и возвращает кортеж с теми же самыми элементами, и конструктор list воспринимает кортеж в качестве аргумента и возвращает список. В результате tuple “замораживает” список, а list его “размораживает”.
##
## Массивы ( array ) 
Для использования массивов необходимо импортировать модуль array.
Массив отличается от листа тем, что в массив можно положить элемент определённого типа. (В зависимости от того, какой тип массива был определён в момент его инициализации)
```python
import array
new_array = array.array('l', any_iterable_object)
```
Конструктор массив принимает на вход TypeCode и любой итерируемый объект (последний необязательно.)
|Код типа	|Тип в C|	Тип в python|	Минимальный размер в байтах|
|:-|:---:|:----:|-:|
|'b'|	signed char|	int|	1|
|'B'|	unsigned char|	int	|1|
|'h'|	signed short	|int|	2|
|'H'|	unsigned short	|int	|2|
|'i'|	signed int	|int	|2|
|'I'|	unsigned int|	int	|2|
|'l'|	signed long	|int|	4|
|'L'|	unsigned long	|int|	4|
|'q'|	signed long long|	int|	8|
|'Q'|	unsigned long long|	int|	8|
|'f'|	float	|float	|4|
|'d'|	double	|float	|8|
array.typecode - TypeCode символ, использованный при создании массива.

- array.itemsize - размер в байтах одного элемента в массиве.

- array.append(х) - добавление элемента в конец массива.

- array.buffer_info() - кортеж (ячейка памяти, длина). Полезно для низкоуровневых операций.

- array.byteswap() - изменить порядок следования байтов в каждом элементе массива. Полезно при чтении данных из файла, написанного на машине с другим порядком байтов.

- array.count(х) - возвращает количество вхождений х в массив.

- array.extend(iter) - добавление элементов из объекта в массив.

- array.frombytes(b) - делает массив array из массива байт. Количество байт должно быть кратно размеру одного элемента в массиве.

- array.fromfile(F, N) - читает N элементов из файла и добавляет их в конец массива. Файл должен быть открыт на бинарное чтение. Если доступно меньше N элементов, генерируется исключение EOFError , но элементы, которые были доступны, добавляются в массив.

- array.fromlist(список) - добавление элементов из списка.

- array.index(х) - номер первого вхождения x в массив.

- array.insert(n, х) - включить новый пункт со значением х в массиве перед номером n. Отрицательные значения рассматриваются относительно конца массива.

- array.pop(i) - удаляет i-ый элемент из массива и возвращает его. По умолчанию удаляется последний элемент.

- array.remove(х) - удалить первое вхождение х из массива.

- array.reverse() - обратный порядок элементов в массиве.

- array.tobytes() - преобразование к байтам.

- array.tofile(f) - запись массива в открытый файл.

- array.tolist() - преобразование массива в список.
##
## Множества ( set ) -- <class 'set'>

**Множество** - "контейнер", содержащий не повторяющиеся элементы в случайном порядке.
> Во множество можно положить только хэшируемые элементы
> 

Способы создания:

- a = set('hello')
- a = set()
- a = set(generator)
- a = set(iterator)

Множества удобно использовать для удаления повторяющихся элементов:
```python

>>> words = ['hello', 'daddy', 'hello', 'mum']
>>> set(words)
>>> {'hello', 'daddy', 'mum'}
```

С множествами можно выполнять множество операций:

- x in s - принадлежит ли x множеству s.
- set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
- set == other - все элементы set принадлежат other, все элементы other принадлежат set.
- set.issubset(other) или set <= other - все элементы set принадлежат other.
- set.issuperset(other) или set >= other - аналогично.
- set.union(other, ...) или set | other | ... - объединение нескольких множеств.
- set.intersection(other, ...) или set & other & ... - пересечение.
- set.difference(other, ...) или set - other - other1 - множество из всех элементов set, не принадлежащие ни одному из other.
- set.symmetric_difference(other) или set ^ other - множество из элементов, встречающихся в каком-либо из множеств, но не встречающиеся в обоих.
- set.copy() - поверхностная копия множества.

И операции, непосредственно изменяющие множество:

- set.update(other, ...); set |= other | ... - объединение.
- set.intersection_update(other, ...); set &= other & ... - пересечение.
- set.difference_update(other, ...); set -= other | ... - вычитание.
- set.symmetric_difference_update(other); set ^= other
- set.add(elem) - добавляет элемент в множество.
- set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
- set.discard(elem) - удаляет элемент, если он находится в множестве.
- set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
- set.clear() - очистка множества.

##
## Неизменяемое множество (frozenset) -- <class 'frozenset'>

Единственное отличие set от frozenset заключается в том, что **set** - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация с списками и кортежами.

В отличие от set, может быть ключем словаря.

##
## Словарь (Dictionary) -- <class 'dict'>

**Словарь** - неупорядоченная коллекция произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

Создать его можно несколькими способами:

- d = {}
- d = {'a': 1, 'b': 2} # Output: {'a': 1, 'b': 2}
- d = dict(short='dict', long='dictionary') # Output: {'short': 'dict', 'long': 'dictionary'} (переменная-значение, нельзя 1='dict')
- d = dict([(1, 1), (2, 4)]) # Output: {1: 1, 2: 4}
- d = dict.fromkeys(['a', 'b']) # Output: {'a': None, 'b': None}
- d = dict.fromkeys(['a', 'b'], 100) # Output: {'a': 100, 'b': 100}

**Замечание**: Присваивание по новому ключу расширяет словарь, присваивание по существующему ключу перезаписывает его, а попытка извлечения несуществующего ключа порождает исключение.

Методы словарей:

- dict.clear() - очищает словарь.
- dict.copy() - возвращает копию словаря.
- classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).
- dict.get(key[, default]) - возвращает значение по ключу, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
- dict.items() - возвращает пары (ключ, значение).
- dict.keys() - возвращает ключи в словаре.
- dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
- dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
- dict.setdefault(key[, default]) - возвращает значение по ключу, но если его нет, не бросает исключение, а создает ключ с значением default (по умолчанию None).
- dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
- dict.values() - возвращает значения в словаре.
## 
## Сопоставление (map) -- <class 'map'>
map принимает два аргумента: функцию отображения, а также итерируемый объект.
```python
new_map = map(lambda x: 2*x, [1, 2, 3])
print(list(new_map)) # [2, 4, 6]
```
Но вообще говоря map способен принимать несколько множеств.
```python
new_map = map(lambda x,y: x*y,[1,2,3],[4,5,6])
print(list(new_map)) # [4, 10, 18]
```
```python
new_map = map(lambda x,y: x*y,[1,2,3],[4,5])
print(list(new_map)) # [4, 10]
```
```python
new_map = map(lambda x,y: x*y,[],[4,5,6])
print(list(new_map)) # []
```
##
## Comprehensions [(PEP 202)](https://www.python.org/dev/peps/pep-0202/)

Это такой синтаксис для создания простого генератора прямо в том месте, где это нужно. Comprehensions условно можно назвать синтаксическим сахаром для цикла for, но у них разное время выполнения. Под капотом генератор также использует цикл for, но выигрывает по скорости из-за того, что не вызывает метод append.

Для **List**:

a_list = [1, '4', 9, 'a', 0, 4]

squared_ints = [e**2 for e in a_list if type(e) == types.IntType] # [1, 81, 0, 16]

Для **Tuple**:

g = tuple(x*x for x in [1, 2, 3, 5, 6, 7, 8] if x % 2 == 0) # (4, 36, 64)

Для **Dict**:

d = {a: a ** 2 for a in range(7)} # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}

Для **Set**:

b = set(x*y for x in range(3) for y in range(3)) # {0, 1, 2, 4}

b = {x ** 2 for x in range(4)}

Создание генератора (Генераторное выражение):

a = (x ** 2 for x in range(4))

type(a) # <class 'generator'>

next(a) # 0

next(a) # 1

Разница между Comprehensions и генераторными выражениями:

В Comprehensions все элементы сохраняются в оперативную память (ест много памяти, нельзя описать бесконечные объекты)

Генераторные выражения при создании ничего не вычисляют -> эффективнее по памяти, позволяют описать бесконечные объекты

### 

![Альтернативный текст](https://sun3-13.userapi.com/QXyPLOkHYJ3jYbiGIDQn0NYEZI6ujDgxkCzRIA/tU3Lyzmmn_4.jpg)

## Модуль Copy

Операция присваивания не копирует объект, она лишь создаёт ссылку на объект. Для изменяемых коллекций, или для коллекций, содержащих изменяемые элементы, часто необходима такая копия, чтобы её можно было изменить, не изменяя оригинал. Данный модуль предоставляет общие (поверхностная и глубокая) операции копирования.

copy.**copy**(x) - возвращает поверхностную копию x (также может быть создана методом .copy() у списков, присваиванием среза (copied_list = original_list[:]), методом .copy() словарей и множеств)

copy.**deepcopy**(x) - возвращает полную копию x.

Исключение copy.error - возникает, если объект невозможно скопировать.

Разница между поверхностным и глубоким копированием существенна только для составных объектов, содержащих изменяемые объекты (например, список списков, или словарь, в качестве значений которого - списки или словари):

- **Поверхностная копия** создает новый составной объект, и затем (по мере возможности) вставляет в него ссылки на объекты, находящиеся в оригинале.
- **Глубокая копия** создает новый составной объект, и затем рекурсивно вставляет в него копии объектов, находящихся в оригинале.

Для операции *глубокого копирования* часто возникают две проблемы, которых нет у операции поверхностного копирования:

- Рекурсивные объекты (составные объекты, которые явно или неявно содержат ссылки на себя) могут стать причиной рекурсивного цикла;
- Поскольку глубокая копия копирует всё, она может скопировать слишком много, например, административные структуры данных, которые должны быть разделяемы даже между копиями.

Функция *deepcopy* решает эти проблемы путем:

- Хранения "memo" словаря объектов, скопированных во время текущего прохода копирования;
- Позволения классам, определенным пользователем, переопределять операцию копирования или набор копируемых компонентов.

Этот модуль не копирует типы вроде модулей, классов, функций, методов, следа в стеке, стековых кадров, файлов, сокетов, окон, и подобных типов.

Для того, чтобы определить собственную реализацию копирования, класс может определить специальные методы __copy__() и __deepcopy__(). Если реализация __deepcopy__() нуждается в создании глубокой копии компонента, то он должен вызвать функцию deepcopy() с компонентом в качестве первого аргумента и словарем memo в качестве второго аргумента.

Пример реализации __copy__ и __deepcopy__:
```python
    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        return result
    
    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            setattr(result, k, deepcopy(v, memo))
        return result
```
##
## Модуль Collections

[https://python-scripts.com/import-collections](https://python-scripts.com/import-collections)

### 1) collections.**Counter** - вид словаря, который позволяет нам считать количество неизменяемых объектов (в большинстве случаев, строк).

Примеры создания:

- c = Counter() # a new, empty counter
- c = Counter('gallahad') # a new counter from an iterable

- c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping

- c = Counter(cats=4, dogs=8) # a new counter from keyword args
```python
  >>> import collections
  >>> c = collections.Counter()
  >>> for word in ['spam', 'egg', 'spam', 'counter', 'counter', 'spam']:
  >>> ...    c[word] += 1
  >>> print(c)
  >>> Counter({'spam': 3, 'counter': 2, 'egg': 1})
```

Специальные методы:

- c.elements() - возвращает список элементов в лексикографическом порядке.
- c.most_common([n]) - возвращает n наиболее часто встречающихся элементов, в порядке убывания встречаемости. Если n не указано, возвращаются все элементы.
- c.subtract([iterable-or-mapping]) - вычитание
- sum(c.values()) - общее количество.
- c.clear() - очистить Counter.
- list\(c\) - список уникальных элементов.
- set\(c\) - преобразовать в множество.
- dict\(c\) - преобразовать в словарь.
- c.most_common()[:-n:-1] - n наименее часто встречающихся элементов.
- c += Counter() - удалить элементы, встречающиеся менее одного раза.

Counter также поддерживает сложение, вычитание, пересечение и объединение

### 2) collections.**defaultdict** ничем не отличается от обычного словаря за исключением того, что по умолчанию всегда вызывается функция, возвращающая значение:
```python
>>> import collections
>>> defdict = collections.defaultdict(list)
>>> print(defdict)
defaultdict(<class 'list'>, {})
>>> for i in range(5):
...    defdict[i].append(i)
>>> print(defdict)
defaultdict(<class 'list'>, {0: [0], 1: [1], 2: [2], 3: [3], 4: [4]}
```
> Этот словарь как бы наполнен элементами, которые вернула функция, указанная в аргументе инициализатора.
### 3) collections**.deque**(iterable, [maxlen]) - создаёт очередь из итерируемого объекта с максимальной длиной maxlen. Очереди очень похожи на списки, за исключением того, что добавлять и удалять элементы можно либо справа, либо слева.
> Очередь представляет из себя аналог LinkedList, но с возможностью указать максимальную длину.
> При чём, если не указать параметр maxlen, то в deque можно будет положить неограниченное количество элементов.
Методы, определённые в deque:

- **append**(x) - добавляет x в конец.
- **appendleft**(x) - добавляет x в начало.
- **clear**() - очищает очередь.
- **count**(x) - количество элементов, равных x.
- **extend**(iterable) - добавляет в конец все элементы iterable.
- **extendleft**(iterable) - добавляет в начало все элементы iterable (начиная с последнего элемента iterable).
- **pop**() - удаляет и возвращает последний элемент очереди.
- **popleft**() - удаляет и возвращает первый элемент очереди.
- **remove**(value) - удаляет первое вхождение value.
- **reverse**() - разворачивает очередь.
- **rotate**(n) - последовательно переносит n элементов из начала в конец (если n отрицательно, то с конца в начало).

### 4) collections**.OrderedDict** - ещё один похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи. (стоит отметить, что в python 3.7 стандартные словари также помнят порядок, в котором элементы были добавлены. И при итерировании этот порядок сохраняется). Методы:

- **popitem**(last=True) - удаляет и возвращает последний элемент если last=True, и первый, если last=False.

- **move_to_end**(key, last=True) - смещает существующий ключ в конец если last=True, и в начало, если last=False.
```python
  >>> d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}
  >>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))
  >>> OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])
  >>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))
  >>> OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
  >>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
  >>> OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])
```

### 5) collections.**namedtuple** позволяет создать тип данных, ведущий себя как кортеж, с тем дополнением, что каждому элементу присваивается имя, по которому можно в дальнейшем получать доступ:
```python
    >>> Point = namedtuple('Point', ['x', 'y'])
    >>> t = [11, 22]
    >>> Point._make(t)
    Point(x=11, y=22)
    >>> p = Point(x=11, y=22)
    >>> p._replace(x=33)
    Point(x=33, y=22)
    >>> p._fields
    ('x', 'y')
    >>> Status = namedtuple('Status', 'open pending closed')._make(range(3))
    >>> Status.open, Status.pending, Status.closed
    (0, 1, 2)
```

### 6) collections.**ChainMap**(*maps) предназначен для быстрого связывания нескольких отображений, чтобы их можно было рассматривать как единое целое. Это часто намного быстрее, чем создание нового словаря и выполнение нескольких вызовов update ().

##
## Модуль heapq

Этот модуль обеспечивает реализацию алгоритма очереди кучи, также известного как алгоритм очереди приоритетов.

Кучи - это двоичные деревья, для которых каждый родительский узел имеет значение, меньшее или равное любому из его дочерних элементов. В этой реализации используются массивы, для которых:
$heap [k] <= heap [2 * k + 1]$

$heap [k] <= heap [2 * k + 2]$

для всех k, считая элементы с нуля. Для сравнения, несуществующие элементы считаются бесконечными. Интересным свойством кучи является то, что ее наименьшим элементом всегда является корень, heap [0].

Чтобы создать кучу, используется список, инициализированный [], или вы можете преобразовать заполненный список в кучу с помощью функции heapify ().

Предоставляются следующие методы:

- heapq.heappush(heap, item) - поместить элемент в кучу, сохраняя инвариант кучи

- heapq.heappop(heap) - достается и возвращается наименьший элемент из кучи, сохраняя инвариант кучи. Если куча пуста, IndexError. Чтобы получить доступ к наименьшему элементу, не выталкивая его, используйте heap[0].

- heapq.heappushpop(heap, item) — push элемент в кучу, затем pop самый маленький элемент из кучи. Быстрее, чем heappush() + heappop().

- heapq.heapify (х) - преобразовать список x в кучу за линейное время.

- heapq.heapreplace(heap, item) — pop наименьший элемент из кучи и push item. Размер кучи не меняется. Если куча пуста, IndexError. Быстрее, чем heappop() + heappush(), и может быть более подходящей при использовании кучи фиксированного размера.

- heapq.merge(*iterables, key=None, reverse=False) - Объединить несколько отсортированных входов в один отсортированный вывод

- heapq.nlargest(n, iterable, key=None) - Вернуть список с n самыми большими элементами из набора данных, определенного с помощью iterable

- heapq.nsmallest(n, iterable, key=None) — аналогично прошлому, только с наименьшими.
```python
  import heapq

  x = [15, 5, 10, 5, 2]
  heapq.heapify(x)
  heapq.heappush(x, 20)
  print(x) # [2, 5, 10, 5, 15, 20]
```

## 
## Модуль enum

Перечисление - это набор символических имен (членов), привязанных к уникальным постоянным значениям. Внутри перечисления члены могут сравниваться по идентичности, а само перечисление может повторяться.

enum.**Enum** - Базовый класс для создания перечисляемых констант.

enum.**IntEnum** - Базовый класс для создания перечисляемых констант, которые также являются подклассами int.

enum.**IntFlag** - Базовый класс для создания перечисляемых констант, которые можно комбинировать, используя побитовые операторы, не теряя своего членства в IntFlag. Члены IntFlag также являются подклассами int.

enum.**Flag** - Базовый класс для создания перечисляемых констант, которые можно комбинировать, используя побитовые операции, не теряя членства в Flag.
```python
    >>> from enum import Enum
    >>> class Shake(Enum):
    ... 	VANILLA = 7
    ... 	CHOCOLATE = 4
    ... 	COOKIES = 9
    ... 	MINT = 3
    ...
    >>> for shake in Shake:
    ... 	print(shake)
    ...
    Shake.VANILLA
    Shake.CHOCOLATE
    Shake.COOKIES
    Shake.MINT
```

enum.**unique**() - Декоратор класса Enum, обеспечивающий привязку только одного имени к какому-либо одному значению.
```python
    >>> from enum import Enum, unique
    >>> @unique
    ... class Mistake(Enum):
    ... 	ONE = 1
    ... 	TWO = 2
    ... 	THREE = 3
    ... 	FOUR = 3
    ...
    Traceback (most recent call last):
    ...
    ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE
```

enum.**auto** - Экземпляры заменяются соответствующими значениями для членов Enum.
```python
    >>> from enum import Enum, auto
    >>> class Color(Enum):
    ... 	RED = auto()
    ... 	BLUE = auto()
    ... 	GREEN = auto()
    ...
    >>> list(Color)
    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]
```

Значения выбираются _generate_next_value_ (), который можно переопределить:
```python
    >>> class AutoName(Enum):
    ... 	def _generate_next_value_(name, start, count, last_values):
    ...     		return name
    ...
    >>> class Ordinal(AutoName):
    ... 	NORTH = auto()
    ... 	SOUTH = auto()
    ... 	EAST = auto()
    ... 	WEST = auto()
    ...
    >>> list(Ordinal)
    [<Ordinal.NORTH: 'NORTH'>, <Ordinal.SOUTH: 'SOUTH'>, <Ordinal.EAST: 'EAST'>, <Ordinal.WEST: 'WEST'>]
```