# 4. Работа с файлами и бинарными данными.
Модули os, os.path, glob, struct

1. Для открытия файла используется функция open(*file*, *mode='r'*, *buffering=-1*, *encoding=None*, *errors=None*, *newline=None*, *closefd=True*, *opener=None*)

```jsx

```

Функция возвращает файловый объект. Обязателен только первый аргумент. Имя файла может быть абсолютным или относительным. Если остальные параметры отсутствуют, файл будет доступен на чтение. Таблица режимов (mode) функции open:

- 'r' – чтение. Если указанного файла нет - получим ошибку.
- 'w' – запись. Если файл с указанным именем уже существует, он будет перезаписан
- 'a' – добавление в конец
- 'b' – бинарный режим. Используется с ‘w’ или ‘r’. Добавляется пост-/суф-фиксом.
- 'r+' – чтение и запись.

*Замечание*: почему есть режим ‘r+’, если для чтения и записи можно использовать комбинацию ‘rw’? Python копирует режимы из функции open() языка C. ‘r+’ - это то, что использует C, и Python придерживался 40-лет

+

+него соглашения.

Третий параметр устанавливает размер буферизации при работе с файлом. По умолчанию он выключен, и чтение/запись идет напрямую с диска на диск. Если значение аргумента указано 1 - файл с построчной буферизацией, больше одного - процесс буферизации выполняется с указанным размером буфера. Отрицательное число - размер буфера будет равен системному.

2. **Атрибуты объекта** - появляются, как только файл был открыт и появился файловый объект:

[Copy of Untitled](https://www.notion.so/87fc6f07f9c844d6ab68e14aa6efba6e)

3. Для записи в файл используется метод **write().** Записывает любую строку(или байты, в зависимости от режима) в открытый файл. Важно помнить, что строки в Python могут содержать двоичные данные, а не только текст.

Метод write() не добавляет символ переноса строки ('\n') в конец файла. Для этого можно использовать print(text, file=file) - добавится перевод строки или другой указанный разделитель.

4. Метод **read()** читает строку (байты) из открытого файла.

[Copy of Untitled](https://www.notion.so/0604b8ffe32c4de499fdfceecae75def)

Необязательный параметр count - это количество байт, которые следует прочитать из открытого файла. Этот метод читает информацию с начала файла и, если параметр count не указан, до конца файла.

Для произвольного доступа к файлу есть функция seek:

seek(offset[, whence])

whence – по умолчанию равен нулю, указывает на то, что смещение берется относительно начала файла.

Есть три возможных значения для whence, которые определяют, относительно чего берётся смещение: начала файла (по умолчанию), текущей позиции, конца файла. Эти значения (числа 0, 1, 2) лежат в константах os.SEEK_...

offset – смещение в байтах.

Функция tell() возвращает текущую позицию файла.

Методы read() и readlines() загружают в память сразу весь файл. Их можно использовать при работе с небольшими файлами.

Для работы с потенциально большими файлами необходимо использовать вызовы

readline() и read(N)

5.Построчная работа с файлами.

Прочитать одну строку:

file.readline()

Функция readline() без параметра читает всю строку, наличие параметра указывает функции максимальное число символов строки, которое будет прочитано.

Прочитать все строки и вернуть список строк:

file.readlines()

Записать строки в файл:

file.writelines()

6. **Закрытие файла.** Для закрытия файла есть метод close(). Обычно файл закрывается сам после того, как вы выходите из программы, но файлы нужно закрывать вручную по нескольким причинам.

1. Питон может буферизировать запись в файл ваших данных, что может привести к неожиданным эффектам и возникновению ошибок.
2. У операционной системы есть ограничение на число одновременно открытых файлов.
3. При доступе к файлу из разных мест одновременно и на чтение, и на запись необходимо синхронизировать файловые операции. Буферизация записи может привести к тому, что запись уже произошла, а данных в файле еще нет.

Для полной уверенности в закрытии файла можно использовать блок try/finally:

[Copy of Untitled](https://www.notion.so/ea3e7d96b6b843e5b388f095ec72721d)

Для работы с файлом рекомендуется использовать менеджер контекста, который в любом случае закроет файл:

[Copy of Untitled](https://www.notion.so/586163ddb5094df39c112444bfc840a1)

### 

### Модуль struct

Для работы с бинарными данными используется модуль struct. Он предлагает функции pack() и unpack() для работы с форматами двоичных записей переменной длины.

***pack(format, value1, value2...)*** - делает из value байты(байтовую строку). В format вы указываете какой тип данных вы хотите сохранить. к примеру хотим сохранить 2 инта(**ii**) и 1 флоат(**f**), тогда это будет так: ***pack('iif', 3, 2, 1.5)*.** Для каждого типа есть свое обозначение (есть в документации).

***pack_into(format, buffer, offset, v1, v2, ...)*** - упаковывает значения v1, v2, ... в соответствии с заданным форматом, записывает упакованные байты в буфер записи, начиная со смещения. Смещение является обязательным аргументом.

***unpack(format, string)*** - из строки байт переданного типа данных возвращает tuple с исходной информацией. Строка должна содержать именно тот объем данных, который требуется для формата (len(string)=calcsize(format)).

***unpack_from(format, buffer[, offset=0])*** - аналогичная распаковка буфера в соответствии с заданным форматом. Буфер должен содержать как минимум объем данных, требуемый форматом (len(buffer[offset:]) >= calcsize(format)).

***calcsize(format)*** - возвращает размер структуры в байтах.

Упорядочение символов формата может повлиять на размер, так как требования по выравниванию отличаются у разных типов данных. Это хорошо видно на следующем примере(с - char, i - int) :

![4%20os%20os%20path%20glob%20struct%20e7bdf7a9ea6b4cd78239d0102519f742/image2.png](4%20os%20os%20path%20glob%20struct%20e7bdf7a9ea6b4cd78239d0102519f742/image2.png)

[документация](https://docs.python.org/3.5/library/struct.html#format-characters)

### 

### Модуль os

Стандартный модуль os имеет интерфейс работы с файловой системой и не только. Причём поведение функций, как правило, не зависит от ОС, поэтому программы остаются переносимыми. Но будьте внимательны: некоторые функции из этого модуля поддерживаются не всеми ОС.

os.**name** - имя операционной системы. Доступные варианты: 'posix', 'nt', 'mac', 'os2', 'ce', 'java'.

os.**environ** - словарь переменных окружения. Изменяемый (можно добавлять и удалять переменные окружения).

os.**getlogin**() - имя пользователя.

os.**getpid**() - текущий id процесса.

os.**uname**() - информация об ОС (Unix). возвращает объект с атрибутами: sysname - имя операционной системы, nodename - имя машины в сети (определяется реализацией), release - релиз, version - версия, machine - идентификатор машины.

os.**access**(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True) - проверка доступа к объекту у текущего пользователя. Флаги:

- os.F_OK - объект существует,
- os.R_OK - доступен на чтение,
- os.W_OK - доступен на запись,
- os.X_OK - доступен на исполнение.

os.**chdir**(path) - смена текущей директории.

os.**chmod**(path, mode, *, dir_fd=None, follow_symlinks=True) - смена прав доступа к объекту (mode - восьмеричное число).

os.**listdir**(path=".") - список файлов и директорий в папке.

os.**mkdir**(path, mode=0o777, *, dir_fd=None) - создаёт директорию. OSError, если директория существует.

os.**remove**(path, *, dir_fd=None) - удаляет файл.

os.**rename**(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает файл или директорию из src в dst.

os.**system**(command) - исполняет системную команду, возвращает код её завершения (в случае успеха 0).

[Полный список методов.](https://docs.python.org/3.5/library/os.html)

[http://ilnurgi1.ru/docs/python/modules/os.html?highlight=os#module-os](http://ilnurgi1.ru/docs/python/modules/os.html?highlight=os#module-os)

### 

### Вложенный модуль os.path

[http://ilnurgi1.ru/docs/python/modules/ospath.html](http://ilnurgi1.ru/docs/python/modules/ospath.html)

Реализует некоторые полезные функции на работы с путями.

os.path.**abspath**(path) - возвращает нормализованный абсолютный путь.

os.path.**basename**(path) - базовое имя пути (эквивалентно os.path.split(path)[1]).

os.path.**dirname**(path) - возвращает имя директории пути path.

os.path.**exists**(path) - возвращает True, если path указывает на существующий путь или дескриптор открытого файла.

os.path.**getsize**(path) - размер файла в байтах.

os.path.**isabs**(path) - является ли путь абсолютным.

os.path.**isfile**(path) - является ли путь файлом.

os.path.**isdir**(path) - является ли путь директорией.

os.path.**islink**(path) - является ли путь символической ссылкой.

os.path.**ismount**(path) - является ли путь точкой монтирования.

os.path.**join**(path1[, path2[, ...]]) - соединяет пути с учётом особенностей операционной системы.

os.path.**normcase**(path) - нормализует регистр пути. На Windows меняет "/" на "\". Если путь регистронезависимый, то переводит в нижний регистр. На файловых системах, не учитывающих регистр, приводит путь к нижнему регистру.

os.path.**normpath**(path) - нормализует путь, убирая избыточные разделители и ссылки на предыдущие директории. На Windows преобразует прямые слеши в обратные.

os.path.**samefile**(path1, path2) - указывают ли path1 и path2 на один и тот же файл или директорию.

os.path.**split**(path) - разбивает путь на кортеж (голова, хвост), где хвост - последний компонент пути, а голова - всё остальное. Хвост никогда не начинается со слеша (если путь заканчивается слешем, то хвост пустой). Если слешей в пути нет, то пустой будет голова.

os.path.**supports_unicode_filenames** - поддерживает ли файловая система Unicode.

os.path.**expanduser**(path) - заменяет все вхождения символа тильда на домашний каталог (берет их из HOMEPATH)

os.path.**expandvars**(path) - заменяет все вхождения символов $VAR на соответствующую переменную окружения (берет из из os.environ)

[Полный список методов.](https://docs.python.org/3.5/library/os.path.html#module-os.path)

### 

### Модуль glob

Модуль glob находит все пути, совпадающие с заданным шаблоном в соответствии с правилами, используемыми оболочкой Unix. Обрабатываются символы "*" (произвольное количество символов), "?" (один символ), и диапазоны символов с помощью [].

Для поиска спецсимволов, заключайте их в квадратные скобки. Например, [?] соответствует символу "?".

glob.**glob**(pathname) - возвращает список (возможно, пустой) путей, соответствующих шаблону pathname. Путь может быть как абсолютным (например, /usr/src/Python-1.5/Makefile), так и относительным (как ../../Tools/*/*.gif).

glob.**iglob**(pathname) - возвращает итератор, дающий те же значения, что и glob.**glob**.

glob.**escape**(pathname) - экранирует все специальные символы для glob ("?", "*" и "["). Специальные символы в имени диска не экранируются (так как они там не учитываются), то есть в Windows escape("//?/c:/Quo vadis?.txt") возвращается:

"//?/c:/Quo vadis[?].txt".

![4%20os%20os%20path%20glob%20struct%20e7bdf7a9ea6b4cd78239d0102519f742/image40.png](4%20os%20os%20path%20glob%20struct%20e7bdf7a9ea6b4cd78239d0102519f742/image40.png)

Если в recursive установлено True, то шаблону "**" будут соответствовать любые файлы и 0 или более директорий или поддиректорий.